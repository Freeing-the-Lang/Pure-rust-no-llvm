name: "üèóÔ∏è Pure-Rust-No-LLVM ‚Äî Stable LLVM-Free Transpiler + 3OS Verified Release"

on:
  push:
    branches: [ "main" ]
  pull_request:
    types: [ opened, reopened, synchronize ]
  workflow_dispatch:
  schedule:
    - cron: "0 3 * * *"

permissions:
  contents: write

concurrency:
  group: pure-rust-no-llvm-${{ github.ref }}
  cancel-in-progress: false

jobs:

  build-3os:
    name: "üß© LLVM-Free Build ‚Äî ${{ matrix.os }} / Branch ${{ github.ref_name }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60

    strategy:
      fail-fast: false
      matrix:
        os: [ ubuntu-latest, macos-latest, windows-latest ]

    steps:

      - name: "üß≠ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # --------------------------------
      # OS Setup
      # --------------------------------
      - name: "‚öôÔ∏è Setup (Linux)"
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 g++ nasm || sudo apt-get install -y g++ nasm

      - name: "‚öôÔ∏è Setup (macOS)"
        if: runner.os == 'macOS'
        run: |
          brew install nasm || brew reinstall nasm

      - name: "‚öôÔ∏è Setup (Windows)"
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          git config --global core.autocrlf false
          if (-not (Get-Command nasm -ErrorAction SilentlyContinue)) {
            choco install nasm -y --no-progress
          }
          python --version
          g++ --version
          nasm -v
          New-Item -ItemType Directory -Force -Path build | Out-Null

      # --------------------------------
      # Example Rust Source
      # --------------------------------
      - name: "üìù Create Example Source"
        run: |
          mkdir -p examples
          cat << 'EOF' > examples/hello.rs
          fn greet(name: &str) -> i32 {
              println!("Hello, {}", name);
              return 42;
          }

          fn main() {
              let x = 5;
              let y = 10;

              if x < y {
                  println!("x is smaller than y");
              } else {
                  println!("x is not smaller");
              }

              let result = greet("Rust");
              println!("Result: {}", result);
          }
          EOF

      # --------------------------------
      # Rust ‚Üí C++ Transpiler
      # --------------------------------
      - name: "üîÅ Rust ‚Üí C++ Transpiler"
        shell: bash
        env:
          PYTHONIOENCODING: utf-8
        run: |
          mkdir -p build
          cat << 'PYCODE' > build/transpile.py
          import re, os
          src = "examples/hello.rs"
          dst = "build/out.cpp"
          rust = open(src).read().splitlines()
          cpp = [
              "#include <iostream>",
              "#include <string>",
              "using namespace std;",
              ""
          ]
          fn_pattern = re.compile(r"fn\s+(\w+)\s*\((.*?)\)(?:\s*->\s*([\w<&>]+))?\s*\{?")
          let_pattern = re.compile(r"\s*let\s+(\w+)\s*=\s*(.*);")
          print_pattern = re.compile(r'println!\("(.*?)"(?:,\s*(.*?))?\);')
          if_pattern = re.compile(r"if\s+(.*?)\s*\{")
          indent = 0
          for line in rust:
              line = line.strip()
              fn_match = fn_pattern.match(line)
              if fn_match:
                  name, args, ret = fn_match.groups()
                  args_cpp_list = []
                  if args and args.strip():
                      for arg in args.split(","):
                          if ":" in arg:
                              p_name, p_type = arg.split(":", 1)
                              p_name = p_name.strip()
                              p_type = p_type.strip()
                              if "&str" in p_type: p_type = "string"
                              elif "i32" in p_type: p_type = "int"
                              args_cpp_list.append(f"{p_type} {p_name}")
                  args_cpp = ", ".join(args_cpp_list)
                  ret_cpp = "int" if name == "main" else ("int" if (ret and "i32" in ret) else "void")
                  cpp.append(f"{ret_cpp} {name}({args_cpp}) "+"{")
                  indent += 1
                  continue
              let_match = let_pattern.match(line)
              if let_match:
                  var, val = let_match.groups()
                  val = val.strip()
                  if val.startswith('"'):
                      cpp.append("    "*indent + f'string {var} = {val};')
                  else:
                      cpp.append("    "*indent + f'auto {var} = {val};')
                  continue
              pr = print_pattern.match(line)
              if pr:
                  fmt, args = pr.groups()
                  out = fmt
                  if args:
                      parts = out.split("{}")
                      segs = []
                      for i, p in enumerate(parts):
                          segs.append(f'"{p}"')
                          if i < len(parts)-1:
                              arg = args.split(",")[i].strip()
                              segs.append(arg)
                      cpp_line = " << ".join(segs)
                      cpp.append("    "*indent + f"cout << {cpp_line} << endl;")
                  else:
                      cpp.append("    "*indent + f'cout << "{out}" << endl;')
                  continue
              if_match = if_pattern.match(line)
              if if_match:
                  cond = if_match.group(1)
                  cpp.append("    "*indent + f"if ({cond}) "+"{")
                  indent += 1
                  continue
              if line.startswith("} else {"):
                  indent = max(indent-1, 0)
                  cpp.append("    "*indent + "} else {")
                  indent += 1
                  continue
              if line.startswith("return "):
                  val = line[len("return "):].rstrip(";")
                  cpp.append("    "*indent + f"return {val};")
                  continue
              if line == "}":
                  indent = max(indent-1, 0)
                  cpp.append("    "*indent + "}")
                  continue
              if line.endswith("{"):
                  cpp.append("    "*indent + "{")
                  indent += 1
                  continue
          open(dst, "w").write("\n".join(cpp))
          print("OK: generated build/out.cpp")
          PYCODE

          python3 build/transpile.py
          echo "--- out.cpp ---"
          cat build/out.cpp

      # --------------------------------
      # C++ ‚Üí ASM ‚Üí Executable (OS-Safe)
      # --------------------------------
      - name: "‚öôÔ∏è Generate ASM (Linux/macOS)"
        if: runner.os != 'Windows'
        run: |
          mkdir -p build
          g++ -S -masm=intel build/out.cpp -o build/out.asm || (echo "ASM WARN"; true)
          [ -f build/out.asm ] || (echo "‚ùå ASM missing"; exit 1)
          head -n 20 build/out.asm

      - name: "‚öôÔ∏è Generate ASM (Windows)"
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          g++ -S -masm=intel build/out.cpp -o build/out.asm
          if (!(Test-Path "build/out.asm")) {
            Write-Host "‚ùå ASM missing"
            exit 1
          }

      - name: "‚öôÔ∏è Compile Executable"
        shell: bash
        run: |
          mkdir -p output
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            g++ build/out.cpp -o output/app.exe
          else
            g++ build/out.cpp -o output/app
          fi
          ls -lh output

      # --------------------------------
      # ProofLedger (OS-Safe)
      # --------------------------------
      - name: "üßæ ProofLedger"
        shell: bash
        run: |
          cd output
          TARGET=""
          if [ -f app ]; then TARGET="app"; fi
          if [ -f app.exe ]; then TARGET="app.exe"; fi
          [ "$TARGET" = "" ] && echo "‚ùå No executable" && exit 1

          if command -v sha256sum >/dev/null 2>&1; then
            sha256sum "$TARGET" > proofledger.txt
          else
            certutil -hashfile "$TARGET" SHA256 > proofledger.txt
          fi

          echo "" >> proofledger.txt
          echo "--- ProofLedger Metadata ---" >> proofledger.txt
          echo "Generated: $(date -u)" >> proofledger.txt
          echo "OS: ${{ runner.os }}" >> proofledger.txt
          echo "Branch: $GITHUB_REF_NAME" >> proofledger.txt
          echo "Commit: $GITHUB_SHA" >> proofledger.txt

      - name: "üì¶ Upload Artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: "pure-rust-no-llvm-${{ runner.os }}-${{ github.ref_name }}"
          path: |
            output/*
            build/out.cpp
            build/out.asm
          if-no-files-found: warn

  # --------------------------------
  # Multi-OS Verified Release
  # --------------------------------
  release:
    name: "üè∑Ô∏è Verified Multi-OS Release"
    runs-on: ubuntu-latest
    needs: build-3os
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'

    steps:

      - name: "üì• Download"
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: "üßπ Flatten"
        run: |
          mkdir -p dist_flat
          for f in $(find dist -type f); do
            base=$(basename "$f")
            cp "$f" "dist_flat/${RANDOM}-${base}"
          done
          ls -lh dist_flat

      - name: "üè∑Ô∏è Tag"
        id: tagger
        run: |
          SAN=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9.-]/-/g')
          TAG="v${{ github.run_number }}-${SAN}"
          echo "TAG_NAME=$TAG" >> $GITHUB_OUTPUT

      - name: "üöÄ Release"
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tagger.outputs.TAG_NAME }}
          name: "Pure-Rust-No-LLVM Build #${{ github.run_number }} ‚Äî ${{ github.ref_name }}"
          body: |
            üß© **Stable Edition ‚Äî Verified 3OS Build**
            ‚Ä¢ Rust ‚Üí C++ Transpiler
            ‚Ä¢ C++ ‚Üí ASM ‚Üí Executable
            ‚Ä¢ OS-Safe ProofLedger
            ‚Ä¢ No-LLVM Pipeline
            ‚Ä¢ Multi-OS Verified Artifacts
          files: dist_flat/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
