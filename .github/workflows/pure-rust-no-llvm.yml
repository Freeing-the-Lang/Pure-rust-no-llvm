# Workflow name
name: "üèóÔ∏è Pure-Rust-No-LLVM ‚Äî Syntax-Aware Transpiler + 3OS Verified Release"

# --- REFINED TRIGGERS ---
# This is more controlled to prevent spamming releases.
# It now runs on:
# 1. Pushes to the 'main' branch.
# 2. Pull Requests (opened, reopened, or new code pushed).
# 3. The nightly schedule.
# 4. Manual runs (workflow_dispatch).
on:
  push:
    branches: [ "main" ] # <--- Only runs on push to 'main'
  pull_request:
    types: [ opened, reopened, synchronize ] # <--- Removed 'closed'
  workflow_dispatch:
  schedule:
    - cron: "0 3 * * *"

permissions:
  contents: write # <--- Required for creating releases

concurrency:
  group: pure-rust-no-llvm-${{ github.ref }}
  cancel-in-progress: false

jobs:

  build-3os:
    name: "üß© LLVM-Free Build ‚Äî ${{ matrix.os }} / Branch ${{ github.ref_name }}"
    runs-on: ${{ matrix.os }}
    strategy:
      # --- REFINED STRATEGY ---
      # fail-fast: false ensures all 3 OS jobs will run to completion,
      # even if one fails, so you can see all results.
      # Removed 'max-parallel: 1' to allow OSes to build in parallel.
      fail-fast: false
      matrix:
        os: [ ubuntu-latest, macos-latest, windows-latest ]
    timeout-minutes: 60

    steps:

      - name: "üß≠ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # <--- Good, fetches all history

      # -------------------------------
      # Environment Setup (Refined)
      # -------------------------------
      # --- REFINED SETUP ---
      # Split setup into OS-specific steps.
      # 'apt' is for Linux, 'brew' is for macOS.

      - name: "‚öôÔ∏è Setup (Linux)"
        if: runner.os == 'Linux'
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 g++ nasm

      - name: "‚öôÔ∏è Setup (macOS)"
        if: runner.os == 'macOS'
        shell: bash
        run: |
          # g++ (clang) and python3 are pre-installed
          brew install nasm

      - name: "‚öôÔ∏è Setup (Windows)"
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          python --version
          g++ --version
          if (-not (Get-Command nasm -ErrorAction SilentlyContinue)) {
            choco install nasm -y --no-progress
          }
          nasm -v
          git config --global core.autocrlf false
          New-Item -ItemType Directory -Force -Path output | Out-Null


      # -------------------------------
      # Example Rust Source
      # -------------------------------
      - name: "üìù Create Example Rust Source"
        shell: bash
        run: |
          mkdir -p examples
          cat << 'EOF' > examples/hello.rs
fn greet(name: &str) -> i32 {
    println!("Hello, {}", name);
    return 42;
}

fn main() {
    let x = 5;
    let y = 10;

    if x < y {
        println!("x is smaller than y");
    } else {
        println!("x is not smaller");
    }

    let result = greet("Rust");
    println!("Result: {}", result);
}
EOF
          echo "‚úÖ Created examples/hello.rs"


      # -------------------------------
      # Rust ‚Üí C++ Transpiler
      # -------------------------------
      - name: "üîÅ Run Syntax-Aware Rust ‚Üí C++ Transpiler"
        shell: bash
        run: |
          # --- This is your custom Python transpiler logic ---
          # --- (Unchanged) ---
          cat << 'PYCODE' > transpile_rust_to_cpp.py
import re, os

src = "examples/hello.rs"
dst = "out.cpp"

rust = open(src).read().splitlines()
cpp = [
    "#include <iostream>",
    "#include <string>",
    "using namespace std;",
    ""
]

fn_pattern = re.compile(r"fn\s+(\w+)\s*\((.*?)\)\s*->?\s*([\w<&>]+)?\s*\{?")
let_pattern = re.compile(r"\s*let\s+(\w+)\s*=\s*(.*);")
print_pattern = re.compile(r'println!\("(.*?)"(?:,\s*(.*?))?\);')

indent = 0
for line in rust:
    line = line.strip()

    fn_match = fn_pattern.match(line)
    if fn_match:
        name, args, ret = fn_match.groups()
        args_cpp = args.replace("&str", "string").replace(":", "")
        ret_cpp = "int" if (ret and "i32" in ret) else "void"
        cpp.append(f"{ret_cpp} {name}({args_cpp}) "+"{")
        indent += 1
        continue

    let_match = let_pattern.match(line)
    if let_match:
        var, val = let_match.groups()
        if '"' in val or "'" in val:
            cpp.append("    "*indent + f'string {var} = {val};')
        else:
            cpp.append("    "*indent + f'auto {var} = {val};')
        continue

    pr = print_pattern.match(line)
    if pr:
        fmt, args = pr.groups()
        out = fmt
        if args:
            parts = out.split("{}")
            segs = []
            for i, p in enumerate(parts):
                segs.append(f'"{p}"')
                if i < len(parts)-1:
                    arg = args.split(",")[i].strip()
                    segs.append(arg)
            cpp_line = " << ".join(segs)
            cpp.append("    "*indent + f"cout << {cpp_line} << endl;")
        else:
            cpp.append("    "*indent + f'cout << "{out}" << endl;')
        continue

    if line.startswith("return "):
        val = line[len("return "):].rstrip(";")
        cpp.append("    "*indent + f"return {val};")
        continue

    if "{" in line:
        cpp.append("    "*indent + "{")
        indent += 1
        continue

    if "}" in line:
        indent = max(indent-1, 0)
        cpp.append("    "*indent + "}")
        continue

cpp.append("")
open(dst, "w").write("\n".join(cpp))
print(f"‚úÖ Transpiled Rust ‚Üí C++ to {dst}")
PYCODE

          python3 transpile_rust_to_cpp.py
          echo "--- Transpiled C++ (out.cpp) ---"
          cat out.cpp
          echo "---------------------------------"


      # -------------------------------
      # C++ ‚Üí ASM ‚Üí Executable (Refined)
      # -------------------------------
      # --- REFINED BUILD ---
      # This is now much simpler and more robust.
      # 1. We let g++ create the .asm file (as an artifact).
      # 2. We let g++ *also* create the final executable directly.
      # 3. This removes the fragile 'sed' and 'nasm' build chain.
      #    We still install NASM (from setup) in case your
      #    transpiler ever wants to use it directly.

      - name: "‚öôÔ∏è Generate ASM Artifact"
        shell: bash
        run: |
          g++ -S -masm=intel out.cpp -o out.asm
          echo "--- Generated ASM (out.asm) ---"
          head -n 20 out.asm
          echo "-------------------------------"

      - name: "‚öôÔ∏è Compile Executable"
        shell: bash
        run: |
          mkdir -p output
          if [ "${{ runner.os }}" = "Windows" ]; then
            g++ out.cpp -o output/out.exe
          else
            g++ out.cpp -o output/out
          fi
          echo "‚úÖ Compiled executable"
          ls -lh output


      # -------------------------------
      # ProofLedger
      # -------------------------------
      - name: "üßæ Generate ProofLedger"
        shell: bash
        run: |
          cd output
          if command -v sha256sum >/dev/null 2>&1; then
            sha256sum * > proofledger.txt
          else
            # This is the Windows 'certutil' fallback
            certutil -hashfile out.exe SHA256 > proofledger.txt
          fi
          echo "" >> proofledger.txt
          echo "--- ProofLedger ---" >> proofledger.txt
          echo "Generated on: $(date -u)" >> proofledger.txt
          echo "Runner: ${{ runner.os }}" >> proofledger.txt
          echo "Branch: $GITHUB_REF_NAME" >> proofledger.txt
          echo "Commit: $GITHUB_SHA" >> proofledger.txt
          cat proofledger.txt

      - name: "üì¶ Upload Outputs"
        uses: actions/upload-artifact@v4
        with:
          name: "pure-rust-no-llvm-${{ runner.os }}-${{ github.ref_name }}"
          path: |
            output/*
            out.cpp
            out.asm
          if-no-files-found: warn


  # -------------------------------
  # Verified Multi-OS Release
  # -------------------------------
  release:
    name: "üè∑Ô∏è Verified Multi-OS Syntax Transpiler Release"
    runs-on: ubuntu-latest
    needs: build-3os # <--- Depends on all 3 OS builds succeeding

    # --- REFINED RELEASE TRIGGER ---
    # This 'if' condition is the most important change.
    # It ensures this 'release' job ONLY runs if:
    # 1. The event was a 'push' AND it was to the 'main' branch.
    #    OR
    # 2. The workflow was triggered manually (workflow_dispatch).
    # This PREVENTS creating releases for Pull Requests.
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'

    steps:

      - name: "üì• Download Artifacts"
        uses: actions/download-artifact@v4
        with:
          path: dist # <--- Download all artifacts to 'dist' dir

      - name: "üßπ Flatten for Release"
        shell: bash
        run: |
          mkdir -p dist_flat
          idx=0
          # This robustly finds all files in subdirectories and
          # renames them to avoid collisions in the flat dir.
          while IFS= read -r -d '' p; do
            b=$(basename "$p")
            if [ -e "dist_flat/$b" ]; then
              # Handle name collision (e.g., 'out.cpp' from 3 OSes)
              idx=$((idx+1))
              cp "$p" "dist_flat/${idx}-${b}"
            else
              cp "$p" "dist_flat/$b"
            fi
          done < <(find dist -type f -print0)
          echo "--- Flattened Artifacts for Release ---"
          ls -lh dist_flat

      # --- REFINED TAG NAME ---
      # Creates a "sanitized" tag name.
      # If your branch is "feature/new-parser", the tag "v123-feature/new-parser"
      # is invalid. This step changes it to "v123-feature-new-parser".
      - name: "üì¶ Prepare Release Tag"
        id: tagger
        shell: bash
        run: |
          SAN_BRANCH_NAME=$(echo "${{ github.ref_name }}" | sed 's/[^a-zA-Z0-9.-]/-/g')
          TAG_NAME="v${{ github.run_number }}-${SAN_BRANCH_NAME}"
          echo "TAG_NAME=${TAG_NAME}" >> "$GITHUB_OUTPUT"

      - name: "üè∑Ô∏è Create GitHub Release"
        uses: softprops/action-gh-release@v2
        with:
          # Use the sanitized tag from the previous step
          tag_name: ${{ steps.tagger.outputs.TAG_NAME }}
          name: "Pure-Rust-No-LLVM Build #${{ github.run_number }} ‚Äî Branch: ${{ github.ref_name }}"
          body: |
            üß© **Pure-Rust-No-LLVM ‚Äî Syntax-Aware Transpiler Edition**

            ‚Ä¢ Rust ‚Üí C++ Syntax Parsing
            ‚Ä¢ C++ ‚Üí ASM ‚Üí Executable
            ‚Ä¢ ProofLedger (SHA256)
            ‚Ä¢ 3OS Verified
            ‚Ä¢ All artifacts included

            **Branch:** ${{ github.ref_name }}
            **Commit:** ${{ github.sha }}
          files: dist_flat/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
